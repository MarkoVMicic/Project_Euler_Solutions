% Problem link: https://projecteuler.net/problem=12


% Problem Statement:

% The sequence of triangle numbers is generated by adding the natural numbers. 
% So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The 
% first ten terms would be:

% 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

% Let us list the factors of the first seven triangle numbers:

%  1: 1
%  3: 1,3
%  6: 1,2,3,6
% 10: 1,2,5,10
% 15: 1,3,5,15
% 21: 1,3,7,21
% 28: 1,2,4,7,14,28
% We can see that 28 is the first triangle number to have over five divisors.

% What is the value of the first triangle number to have over five hundred 
% divisors?

-module(problem12).
-export([main/1, find_num_factors/1]).

main( N )
->
    triangle_number_with_N_factors( N )
.

triangle_number_with_N_factors( N )
->
    triangle_number_with_N_factors( N, 1, 1, 0)
.
triangle_number_with_N_factors( N,
                                Index,
                                Triangle_Number,
                                Factors ) when Factors > N
->
    % There's a bug somewhere that's returning the next triangle number rather 
    % than the one we want. Fix this. 
    Triangle_Number
;
triangle_number_with_N_factors( N,
                                Index,
                                Triangle_Number,
                                0 )
->
    Factors = find_num_factors( Triangle_Number ),
    triangle_number_with_N_factors( N,
                                    Index,
                                    Triangle_Number,
                                    Factors )
;
triangle_number_with_N_factors( N,
                                Index,
                                Triangle_Number,
                                _Factors)
->
    Next_Triangle_Number = Triangle_Number + Index+1,
    triangle_number_with_N_factors( N, 
                                    Index+1,
                                    Next_Triangle_Number,
                                    0)
.

find_num_factors( 1 )      -> 1;
find_num_factors( 2 )      -> 2;
find_num_factors( 3 )      -> 2;
find_num_factors( 4 )      -> 2;
find_num_factors( Number ) -> 
  find_num_factors( Number, 2, 1, math:sqrt(Number) )
.
find_num_factors( _Number, 
                  Factor, 
                  Factors, 
                  Min_Factor ) when Factor > Min_Factor
->
    Factors+1
;
find_num_factors( Number, 
                  Factor, 
                  Factors, 
                  Min_Factor ) when Number rem Factor == 0
->
    case Factor*Factor == Number of
    true  -> find_num_factors( Number, Factor+1, Factors+1, Min_Factor );
    false -> find_num_factors( Number, Factor+1, Factors+2, Min_Factor )
  end
;
find_num_factors( Number, Factor, Factors, Min_Factor)
->
    find_num_factors( Number, Factor+1, Factors, Min_Factor )
.
